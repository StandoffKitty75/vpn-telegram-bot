# handlers/generate_key.py
from aiogram import Router, F
from aiogram.types import Message
import requests
import json
import os
from datetime import datetime

from config import OUTLINE_API_URL
from localization import texts
from state import user_langs

router = Router()

# –§–∞–π–ª –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–ª—é—á–µ–π
KEYS_FILE = "keys.json"

# –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∫–ª—é—á–∏ (—Å—Ç—Ä—É–∫—Ç—É—Ä–∞: {user_id: {"key": <url>, "username": <username_or_empty>}})
if os.path.exists(KEYS_FILE):
    with open(KEYS_FILE, "r", encoding="utf-8") as f:
        try:
            user_keys = json.load(f)
        except Exception:
            user_keys = {}
else:
    user_keys = {}

def save_keys():
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–ª—é—á–∏ –≤ —Ñ–∞–π–ª"""
    with open(KEYS_FILE, "w", encoding="utf-8") as f:
        json.dump(user_keys, f, indent=4, ensure_ascii=False)

@router.message(F.text == "/key")
async def generate_outline_key(message: Message):
    """
    –í—ã–¥–∞—á–∞ –∫–ª—é—á–∞: –µ—Å–ª–∏ –∫–ª—é—á —É–∂–µ –µ—Å—Ç—å ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π,
    –∏–Ω–∞—á–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —á–µ—Ä–µ–∑ Outline API, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º.
    """
    user_id = str(message.from_user.id)
    lang = user_langs.get(message.from_user.id, "en")
    username = message.from_user.username or ""

    # –ï—Å–ª–∏ –∫–ª—é—á —É–∂–µ –µ—Å—Ç—å ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
    if user_id in user_keys and "key" in user_keys[user_id]:
        existing = user_keys[user_id]["key"]
        response_text = texts[lang].get("key_exists",
                                       "üîë –í—ã —É–∂–µ –∏–º–µ–µ—Ç–µ –∫–ª—é—á:\n`{key}`").format(
            key=existing,
            username=username or message.from_user.id
        )
        await message.answer(response_text, parse_mode="Markdown")
        return

    # –ò–Ω–∞—á–µ ‚Äî –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –∫–ª—é—á —á–µ—Ä–µ–∑ Outline API
    url = f"{OUTLINE_API_URL}/access-keys"
    headers = {"Content-Type": "application/json"}
    data = {
        "name": f"telegram_{user_id}_{message.date.strftime('%Y%m%d_%H%M%S')}"
    }

    try:
        response = requests.post(url, headers=headers, json=data, verify=False)
        response.raise_for_status()

        key_data = response.json()
        access_url = key_data.get("accessUrl")
        key_url = access_url + "#KT_VPN" if access_url else None

        if key_url:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –∏ –Ω–∞ –¥–∏—Å–∫
            user_keys[user_id] = {
                "key": key_url,
                "username": username
            }
            save_keys()

            response_text = texts[lang]["key_success"].format(
                key=key_url,
                username=username or message.from_user.id
            )
            await message.answer(response_text, parse_mode="Markdown")
        else:
            await message.answer(texts[lang]["key_no_response"])

    except requests.exceptions.ConnectionError:
        await message.answer(texts[lang]["key_conn_error"])
    except requests.exceptions.HTTPError as e:
        if e.response is not None and e.response.status_code == 401:
            await message.answer(texts[lang]["key_auth_error"])
        else:
            status = e.response.status_code if e.response is not None else "?"
            await message.answer(texts[lang]["key_http_error"].format(status=status))
    except requests.exceptions.RequestException as e:
        await message.answer(texts[lang]["key_request_error"].format(error=str(e)))
    except Exception as e:
        await message.answer(texts[lang]["key_unexpected_error"].format(error=str(e)))

# --- /reset_key –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏ user_id, –∏ username ---
ADMIN_ID = 5880556451  # <- –∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–π Telegram ID

@router.message(F.text.startswith("/reset_key"))
async def reset_key(message: Message):
    """
    –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
      /reset_key <user_id>   - —Å–±—Ä–æ—Å –ø–æ —á–∏—Å–ª–æ–≤–æ–º—É ID
      /reset_key @username   - —Å–±—Ä–æ—Å –ø–æ username (—Å @ –∏–ª–∏ –±–µ–∑)
    –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è ADMIN_ID.
    """
    if message.from_user.id != ADMIN_ID:
        await message.answer("‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    parts = message.text.split(maxsplit=1)
    if len(parts) < 2:
        await message.answer("‚ö† –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /reset_key <user_id|@username|username>")
        return

    target = parts[1].strip()
    target_id = None
    found_user_id = None

    # –ï—Å–ª–∏ —á–∏—Å–ª–æ–≤–æ–π id
    if target.isdigit():
        target_id = target
        if target_id in user_keys:
            user_keys.pop(target_id)
            save_keys()
            await message.answer(f"‚úÖ –ö–ª—é—á –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id} —Å–±—Ä–æ—à–µ–Ω.")
            return
        else:
            await message.answer(f"‚ùå –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id} –Ω–µ –Ω–∞–π–¥–µ–Ω —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π –∫–ª—é—á.")
            return
    # –ï—Å–ª–∏ username (—Å @ –∏–ª–∏ –±–µ–∑)
    if target.startswith("@"):
        target = target[1:]

    # –ò—â–µ–º –ø–æ username –≤ user_keys
    for uid, info in user_keys.items():
        if isinstance(info, dict) and info.get("username"):
            if info.get("username").lstrip("@").lower() == target.lstrip("@").lower():
                found_user_id = uid
                break

    if found_user_id:
        user_keys.pop(found_user_id)
        save_keys()
        await message.answer(f"‚úÖ –ö–ª—é—á –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è @{target} (ID {found_user_id}) —Å–±—Ä–æ—à–µ–Ω.")
        return

    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ ‚Äî —Å–æ–æ–±—â–∞–µ–º
    await message.answer(f"‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å username @{target} –∏–ª–∏ id {target}.")
